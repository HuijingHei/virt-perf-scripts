#!/usr/bin/env python

# Interface between StoragePerformanceTest.py
# StoragePerformanceTest.py should do:
# 1. the fio outputs should be at least in json+ format
#    the "fio --group_reporting" must be used
# 2. save the fio outputs into *.fiolog
# 3. put all *.fiolog files into ./fio_result/
# 4. empty ./fio_report/ folder
# 5. pass the additional information by "fio --description"
#    a) "driver" - frontend driver, such as SCSI or IDE
#    b) "format" - the disk format, such as raw or xfs
#    c) "round" - the round number, such as 1, 2, 3...
#    d) "backend" - the hardware which data image based on

import json
import re
import os
import prettytable

import click
import pandas as pd


class FioTestReporter():
    '''
    Get, deal with and covert the performance KPI data from FIO tools.
    '''

    # The list of raw data, the item is loaded from fio output file.
    # Each item is a full data source (raw data) in json format.
    raw_data_list = []

    # The list of performance KPIs, which are extracted from the raw data.
    # Each item represents a single fio test in python dict format.
    perf_kpi_list = []

    # The table of performance KPIs, which is powered by PrettyTable.
    table = None

    def _get_raw_data_from_fio_log(self, data_file):
        """Get the raw data from a specified fio log file.

        This function open a specified fio log file and read the first json
        block which is expected to be generated by the fio --output=json/json+.
        Then it converts this block into Python dict format and returns it.

        Function byteify will convert the unicode string to bytes.

        Args:
            data_file: string, the path to the fio log file.

        Returns:
            This function returns a tuple like (result, raw_data):
            result:
                0: Passed
                1: Failed
            raw_data:
                The raw data in Python dict format.

        Raises:
            1. Error while handling fio log file
            2. Error while handling the new json file

        """

        def byteify(inputs):
            """Convert unicode to utf-8 string."""
            if isinstance(inputs, dict):
                return {
                    byteify(key): byteify(value)
                    for key, value in inputs.iteritems()
                }
            elif isinstance(inputs, list):
                return [byteify(element) for element in inputs]
            elif isinstance(inputs, unicode):
                return inputs.encode('utf-8')
            else:
                return inputs

        # Parse required params
        if data_file == '':
            print 'Missing required params: data_file'
            return (1, None)

        # Get the offsets of the first json block
        try:
            with open(data_file, 'r') as f:
                file_content = f.readlines()

            # Locate the first json block
            begin = end = num = 0
            while num < len(file_content):
                if re.search(r'^{', file_content[num]):
                    begin = num
                    break
                num += 1
            while num < len(file_content):
                if re.search(r'^}', file_content[num]):
                    end = num
                    break
                num += 1
        except Exception, err:
            print 'Error while handling fio log file: %s' % err
            return (1, None)

        # Extract the json block into a new file and get the raw_data
        if begin >= end:
            print 'Cannot found validate json block in file: %s' % data_file
            return (1, None)

        try:
            with open(data_file + '.json', 'w') as json_file:
                json_file.writelines(file_content[begin:end + 1])
            with open(data_file + '.json', 'r') as json_file:
                json_data = json.load(json_file)
                raw_data = byteify(json_data)
        except Exception, err:
            print 'Error while handling the new json file: %s' % err
            return (1, None)

        os.unlink(data_file + '.json')
        return (0, raw_data)

    def load_raw_data_from_fio_logs(self, params={}):
        """Load raw data from fio log files.

        This function loads raw data from a sort of fio log files and stores
        the raw data (in Python dict format) into self.raw_data_list.

        Args:
            params: dict
                result_path: string, the path where the fio log files located.

        Returns:
            0: Passed
            1: Failed

        Updates:
            self.raw_data_list: store all the raw data;

        """

        # Parse required params
        if 'result_path' not in params:
            print 'Missing required params: params[result_path]'
            return 1

        # load raw data from files
        for basename in os.listdir(params['result_path']):
            filename = params['result_path'] + '/' + basename

            if filename.endswith('.fiolog') and os.path.isfile(filename):
                (result, raw_data) = self._get_raw_data_from_fio_log(filename)
                if result == 0:
                    self.raw_data_list.append(raw_data)

        return 0

    def _get_kpis_from_raw_data(self, raw_data):
        """Get KPIs from a specified raw data.

        This function get the performance KPIs from a specified tuple of raw
        data. It converts the units and format the values so that people can
        read them conveniently.

        Args:
            raw_data: dict, the specified raw data.

        Returns:
            This function returns a tuple like (result, perf_kpi):
            result:
                0: Passed
                1: Failed
            perf_kpi:
                The performance KPIs in Python dict format.

        Raises:
            1. Error while extracting performance KPIs

        """
        # Parse required params
        if raw_data == '':
            print 'Missing required params: raw_data'
            return (1, None)

        # Get the performance KPIs
        perf_kpi = {}

        try:
            perf_kpi['rw'] = raw_data['jobs'][0]['job options']['rw']
            perf_kpi['bs'] = raw_data['jobs'][0]['job options']['bs']
            perf_kpi['iodepth'] = raw_data['jobs'][0]['job options']['iodepth']
            perf_kpi['numjobs'] = raw_data['jobs'][0]['job options']['numjobs']

            # The unit of "bw" was "KiB/s", convert to "MiB/s"
            perf_kpi['r-bw'] = raw_data['jobs'][0]['read']['bw'] / 1024.0
            perf_kpi['w-bw'] = raw_data['jobs'][0]['write']['bw'] / 1024.0
            perf_kpi['bw'] = perf_kpi['r-bw'] + perf_kpi['w-bw']

            # The IOPS was a decimal, make it an integer
            perf_kpi['r-iops'] = int(raw_data['jobs'][0]['read']['iops'])
            perf_kpi['w-iops'] = int(raw_data['jobs'][0]['write']['iops'])
            perf_kpi['iops'] = perf_kpi['r-iops'] + perf_kpi['w-iops']

            # The unit of "lat" was "ns", convert to "ms"
            perf_kpi['r-lat'] = raw_data['jobs'][0]['read']['lat_ns'][
                'mean'] / 1000000.0
            perf_kpi['w-lat'] = raw_data['jobs'][0]['write']['lat_ns'][
                'mean'] / 1000000.0
            perf_kpi['lat'] = perf_kpi['r-lat'] + perf_kpi['w-lat']

            # Get util% of the disk
            if len(raw_data['disk_util']) == 1:
                perf_kpi['util'] = raw_data['disk_util'][0]['util']
            else:
                print 'Error while parsing disk_util: length != 1'
                perf_kpi['util'] = 'error'

            # Get additional information
            try:
                dict = eval(raw_data['jobs'][0]['job options']['description'])
                perf_kpi.update(dict)
            except Exception, err:
                print 'Error while parsing additional information: %s' % err

            if 'driver' not in perf_kpi:
                perf_kpi['driver'] = 'n/a'
            if 'format' not in perf_kpi:
                perf_kpi['format'] = 'n/a'
            if 'round' not in perf_kpi:
                perf_kpi['round'] = 'n/a'
            if 'backend' not in perf_kpi:
                perf_kpi['backend'] = 'n/a'

        except Exception, err:
            print 'Error while extracting performance KPIs: %s' % err
            return (1, None)

        return (0, perf_kpi)

    def calculate_performance_kpis(self, params={}):
        """Calculate performance KPIs.

        This function calculates performance KPIs from self.raw_data_list and
        stores the performance KPI tuples into self.perf_kpi_list.

        As data source, the following attributes should be ready to use:
        1. self.raw_data_list: the list of raw data (Python dict format)

        Args:
            params: dict
                None

        Returns:
            0: Passed
            1: Failed

        Updates:
            self.perf_kpi_list: store the performance KPI tuples.

        """
        # Calculate performance KPIs
        for raw_data in self.raw_data_list:
            (result, perf_kpi) = self._get_kpis_from_raw_data(raw_data)
            if result == 0:
                self.perf_kpi_list.append(perf_kpi)
            else:
                return 1

        return 0

    def performance_kpis_to_csv(self):
        """Dump performance KPIs to CSV file."""

        # Create DataFrame
        #print pd.DataFrame(self.perf_kpi_list)
        # Format DataFrame

        # Dump DataFrame to CSV file


    def build_table(self, params={}):
        '''
        This function builds self.table by coverting the data in self.perf_kpi_list.
        '''

        # Build the table from self.perf_kpi_list
        try:
            self.table = prettytable.PrettyTable([
                "Backend", "Driver", "Format", "RW", "BS", "IODepth",
                "Numjobs", "Round", "BW(MiB/s)", "IOPS", "LAT(ms)", "Util(%)"
            ])

            for perf_kpi in self.perf_kpi_list:
                self.table.add_row([
                    perf_kpi['backend'], perf_kpi['driver'],
                    perf_kpi['format'], perf_kpi['rw'], perf_kpi['bs'],
                    perf_kpi['iodepth'], perf_kpi['numjobs'],
                    perf_kpi['round'], perf_kpi['bw'], perf_kpi['iops'],
                    perf_kpi['lat'], perf_kpi['util']
                ])

        except Exception, err:
            print 'Error while building self.table: %s' % err
            return 1

        # Format this table
        self.format_table()

        return 0

    def format_table(self, params={}):
        '''
        This function formats the values in self.table so that people can read
        the outputs conveniently. And this action will not damage the data
        inside the table.
        '''

        # Edit global settings
        self.table.float_format = '.4'

        # Edit pre-colume settings
        self.table.float_format['LAT(ms)'] = '.4'

        return 0

    def print_table(self, params={}):
        '''
        This function makes a copy of self.table, defines the appearance and
        print it out to the console.
        '''

        # Parse required params
        if 'table_style' in params:
            valid_inputs = ('DEFAULT', 'MSWORD_FRIENDLY', 'PLAIN_COLUMNS',
                            'plain')
            if params['table_style'] not in valid_inputs:
                print 'Invalid params: params[table_style]: "%s", the valid inputs are: %s' % (
                    params['table_style'], valid_inputs)
                return 1

        # Make a copy of self.table
        my_table = self.table[:]

        # Edit the appearance
        if 'table_style' in params:
            if params['table_style'] == 'DEFAULT':
                my_table.set_style(prettytable.DEFAULT)
            if params['table_style'] == 'MSWORD_FRIENDLY':
                my_table.set_style(prettytable.MSWORD_FRIENDLY)
            if params['table_style'] == 'PLAIN_COLUMNS':
                my_table.set_style(prettytable.PLAIN_COLUMNS)
            if params['table_style'] == 'plain':
                my_table.border = False
                my_table.align = 'l'
                my_table.left_padding_width = 0
                my_table.right_padding_width = 2

        # Print the table
        print my_table

        return 0

    def dump_table(self, params={}):
        '''
        This function makes a copy of self.table and dump the data into a csv
        file.
        '''

        # Parse required params
        if 'report_path' not in params:
            print 'Missing required params: params[report_path]'
            return 1

        if 'file_name' not in params:
            print 'Missing required params: params[file_name]'
            return 1

        # Make a copy of self.table
        my_table = self.table[:]

        # Edit the appearance and get the string content
        my_table.set_style(prettytable.PLAIN_COLUMNS)
        content = my_table.get_string()

        # Convert the content to csv format
        try:
            reObj = re.compile('  +')
            content = str(reObj.sub(',', content))
            content = content.replace(',\n', '\n')
            content = content.replace('\n,', '\n')
            content = content.strip(',')

        except Exception, err:
            print 'Error while converting to csv format: %s' % err
            return 1

        # Write the content to a csv file
        try:
            csv_file = params['report_path'] + '/' + params['file_name']
            print 'Dumping data into csv file "%s"...' % csv_file
            with open(csv_file, 'w') as f:
                f.write(content)
            print 'Finished!'

        except Exception, err:
            print 'Error while dumping to csv file: %s' % err
            return 1

        return 0


if __name__ == '__main__':

    ftr = FioTestReporter()
    ftr.load_raw_data_from_fio_logs({'result_path': './fio_result/'})
    ftr.calculate_performance_kpis()

    print ftr.perf_kpi_list

    ftr.performance_kpis_to_csv()

    exit(0)

    '''
    perf_kpis = FioPerformanceKPIs()
    perf_kpis.load_raw_data({'result_path': './fio_result/'})
    perf_kpis.extracts_perf_kpis()

    #print 'perf_kpis.perf_kpi_list:', perf_kpis.perf_kpi_list
    perf_kpis.build_table()
    perf_kpis.print_table()
    perf_kpis.dump_table({
        'report_path': './fio_report/',
        'file_name': 'report.csv'
    })

    exit(0)
    '''
